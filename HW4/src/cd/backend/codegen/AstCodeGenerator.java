package cd.backend.codegen;

import java.io.Writer;
import java.util.List;

import static cd.Config.MAIN;
import cd.Main;
import cd.backend.codegen.RegisterManager.Register;
import cd.ir.Ast.ClassDecl;

public class AstCodeGenerator {

    protected RegsNeededVisitor rnv;
	
    protected ExprGenerator eg;
    protected StmtGenerator sg;
	
    protected final Main main;
	
    protected final AssemblyEmitter emit;
    protected final RegisterManager rm = new RegisterManager();

    protected final LiProgram program;
	
    protected static final String VAR_PREFIX = "var_";

    AstCodeGenerator(Main main, Writer out) {
        {
            initMethodData();
        }
		
        this.emit = new AssemblyEmitter(out);
        this.main = main;
        this.rnv = new RegsNeededVisitor();

        this.eg = new ExprGenerator(this);
        this.sg = new StmtGenerator(this);
    }

    protected void debug(String format, Object... args) {
        this.main.debug(format, args);
    }

    public static AstCodeGenerator createCodeGenerator(Main main, Writer out) {
        return new AstCodeGenerator(main, out);
    }
	
	
    /**
     * Main method. Causes us to emit x86 assembly corresponding to {@code ast}
     * into {@code file}. Throws a {@link RuntimeException} should any I/O error
     * occur.
     * 
     * <p>
     * The generated file will be divided into two sections:
     * <ol>
     * <li>Prologue: Generated by {@link #emitPrefix()}. This contains any
     * introductory declarations and the like.
     * <li>Body: Generated by {@link ExprGenerator}. This contains the main
     * method definitions.
     * </ol>
     */
    public void go(List<? extends ClassDecl> astRoots) {
        program = new LiProgram(astRoots);
        
        // Emit some useful string constants:
        cg.emit.emitRaw(Config.DATA_STR_SECTION);
        cg.emit.emitLabel("STR_NL");
        cg.emit.emitRaw(Config.DOT_STRING + " \"\\n\"");
        cg.emit.emitLabel("STR_D");
        cg.emit.emitRaw(Config.DOT_STRING + " \"%d\"");

        cg.emit.emitRaw(Config.TEXT_SECTION);
        
        for (ClassDecl ast : astRoots) {
            sg.gen(ast);
        }

        cg.emit.emitRaw(".globl "+MAIN);
        cg.emit.emitLabel(MAIN);

        cg.emit.emit("enter", "$8", "$0");
        cg.emit.emit("and", -16, "%esp");

        Register reg = eg.gen(new NewObject("Main"));
        cg.emit.emit("push", reg);
        rm.releaseRegister(reg);
        
        cg.emit.emit("call", "main@Main");
        cg.emit.emit("addl", "4", "%esp");
        
        cg.emitMethodSuffix(true);
    }


    protected void initMethodData() {
        {
            rm.initRegisters();
        }
    }


    protected void emitMethodSuffix(boolean returnNull) {
        if (returnNull)
            emit.emit("movl", "$0", Register.EAX);
        emit.emitRaw("leave");
        emit.emitRaw("ret");
    }
}
